#### 语言基础

##### 1.指针和引用的概念(异同点)

##### 2.指针与内存的关系

##### 3.程序编译过程

##### 4.虚函数实现机制

> 虚函数表在编译时已经确定，保存在.rodata中，而虚函数表指针在对象初始化时构建（发生在运行期）

##### 5.静态链接和动态链接

> 静态链接：将每个独立编译的源代码文件链接起来（处理好各个模块之间相互引用的部分），存在空间浪费和更新困难问题
>
> 动态链接：将链接的过程推迟到运行时

##### 6.c++内存模型

> sdfsd

##### **7.extern关键字作用**

> 用在变量或函数声明前：该声明定义在其他文件，在此处引用
>
> extern "C"：采用c语言的编译命名方式进行编译

##### 8.**volatile关键字**

> CPU读取数据时从内存而不是寄存器读取

##### 9.析构函数不能抛出异常

> 如果析构函数抛出异常，则异常点之后的程序不会执行，如果析构函数在异常点之后执行了某些必要的动作比如释放某些资源，则这些动作不会执行，会造成诸如资源泄漏的问题
>
> 通常异常发生时，c++的机制会调用已经构造对象的析构函数来释放资源，此时若析构函数本身也抛出异常，则前一个异常尚未处理，又有新的异常，会造成程序崩溃的问题

##### 10.内存对齐原则

##### 11.必须在构造函数初始化列表里初始化的数据成员有哪些

> const成员变量，没有默认构造函数的类成员变量，引用类型的成员变量

##### 12.STL里的内存池实现

>  STL内存分配分为一级分配器和二级分配器，一级分配器就是采用malloc分配内存，二级分配器采用内存池。
>
> 二级分配器设计的非常巧妙，分别给8k，16k,..., 128k等比较小的内存片都维持一个空闲链表，每个链表的头节点由一个数组来维护。需要分配内存时从合适大小的链表中取一块下来。假设需要分配一块10K的内存，那么就找到最小的大于等于10k的块，也就是16K，从16K的空闲链表里取出一个用于分配。释放该块内存时，将内存节点归还给链表。
> 如果要分配的内存大于128K则直接调用一级分配器。
> 为了节省维持链表的开销，采用了一个union结构体，分配器使用union里的next指针来指向下一个节点，而用户则使用union的空指针来表示该节点的地址。

##### 13.有关虚表

> 每个含有虚函数的类都有一个虚函数表，虚函数表是所有类对象共享，虚表的构建发生在编译期
>
> 每个含有虚函数的类对象都有一个虚函数表指针，该指针的是每个对象私有的，通常在对象的最前面，其初始化发生在对象的构造函数（在运行期)
>
> 虚函数表不只有函数指针，该表的第一项是一个指向type_info类的指针，RTTI（Runtime Type Identification 运行时类型识别），第二项为偏移量，接下来才是函数指针

##### 14.静态绑定和动态绑定

> 静态绑定：编译时（链接）完成函数地址的绑定
>
> 动态绑定：程序运行后根据具体的环境或用户操作进行的函数地址绑定

##### 15.线程安全的单例

