#### 语言基础

##### 1.指针和引用的概念(异同点)

##### 2.指针与内存的关系

##### 3.程序编译过程

##### 4.虚函数实现机制

> 虚函数表在编译时已经确定，保存在.rodata中，而虚函数表指针在对象初始化时构建（发生在运行期）

##### 5.静态链接和动态链接

> 静态链接：将每个独立编译的源代码文件链接起来（处理好各个模块之间相互引用的部分），存在空间浪费和更新困难问题
>
> 动态链接：将链接的过程推迟到运行时

##### 6.c++内存模型

> sdfsd

##### **7.extern关键字作用**

> 用在变量或函数声明前：该声明定义在其他文件，在此处引用
>
> extern "C"：采用c语言的编译命名方式进行编译

##### 8.**volatile关键字**

> CPU读取数据时从内存而不是寄存器读取

##### 9.析构函数不能抛出异常

> 如果析构函数抛出异常，则异常点之后的程序不会执行，如果析构函数在异常点之后执行了某些必要的动作比如释放某些资源，则这些动作不会执行，会造成诸如资源泄漏的问题
>
> 通常异常发生时，c++的机制会调用已经构造对象的析构函数来释放资源，此时若析构函数本身也抛出异常，则前一个异常尚未处理，又有新的异常，会造成程序崩溃的问题

##### 10.内存对齐原则

##### 11.必须在构造函数初始化列表里初始化的数据成员有哪些

> const成员变量，没有默认构造函数的类成员变量，引用类型的成员变量

##### 12.STL里的内存池实现

>  STL内存分配分为一级分配器和二级分配器，一级分配器就是采用malloc分配内存，二级分配器采用内存池。
>
> 二级分配器设计的非常巧妙，分别给8k，16k,..., 128k等比较小的内存片都维持一个空闲链表，每个链表的头节点由一个数组来维护。需要分配内存时从合适大小的链表中取一块下来。假设需要分配一块10K的内存，那么就找到最小的大于等于10k的块，也就是16K，从16K的空闲链表里取出一个用于分配。释放该块内存时，将内存节点归还给链表。
> 如果要分配的内存大于128K则直接调用一级分配器。
> 为了节省维持链表的开销，采用了一个union结构体，分配器使用union里的next指针来指向下一个节点，而用户则使用union的空指针来表示该节点的地址。

##### 13.有关虚表

> 每个含有虚函数的类都有一个虚函数表，虚函数表是所有类对象共享，虚表的构建发生在编译期
>
> 每个含有虚函数的类对象都有一个虚函数表指针，该指针的是每个对象私有的，通常在对象的最前面，其初始化发生在对象的构造函数（在运行期)
>
> 虚函数表不只有函数指针，该表的第一项是一个指向type_info类的指针，RTTI（Runtime Type Identification 运行时类型识别），第二项为偏移量，接下来才是函数指针

##### 14.静态绑定和动态绑定

> 静态绑定：编译时（链接）完成函数地址的绑定
>
> 动态绑定：程序运行后根据具体的环境或用户操作进行的函数地址绑定

##### 15.线程安全的单例

##### 16.四种类型转换

> const_cast：去除变量const或volatile属性
>
> static_cast：静态类型转换
>
> dynamic_cast：动态类型转换，只用于存在虚函数的父子关系的强制类型转换，对于指针失败返回nullptr，对于引用失败抛异常，运行时检查类型安全
>
> reinterpret_cast：可用于任意类型的指针之间的转换

##### 17.实现只能动态分配的类

> ```c++
> //将类的构造函数和析构函数设为protected属性，这样类对象不能够访问，但是派生类能够访问，能够正常的继承
> class A
> {
> protected:
>     A(){};
>    	~A(){}
> public:
>     static A* Create(){return new A();}
>     void destory(){delete this;}
> }
> ```

##### 18.实现只能静态创建的类

> ```c++
> //将new运算符设为私有
> class A
> {
> private:
>     void* operator new(size_t t){}
>     void operator delete(void* ptr){}
> public:
>     A(){}
>     ~A(){}
> }
> ```

##### 19.在不同文件的两个全局变量怎么保证他们初始化的顺序

> ```c++
> //不直接使用全局变量，用静态变量间接实现
> //函数内部的静态变量是在第一次访问的时候来初始化(存疑)
> int GetA()
> {
> 	static int a = 5;
> 	return a;
> }
> int GetB()
> {
> 	static int b = GetA();
> 	return b;
> }
> ```

##### 20.main函数执行之前需要做哪些准备

> 设置栈指针
>
> 构造non-local static对象
>
> 赋值.bss段的对象
>
> 将argc，argv等传递给main函数，然后调用main函数

##### 21.野指针与悬空指针

> 野指针：不确定具体指向的指针，最长来自于未初始化的指针
>
> 悬空指针：指向已被操作系统回收的内存的指针

##### 22.%只能用于整形，否则编译出错

##### 23.union的所有对象对于基地址的偏移都为0

